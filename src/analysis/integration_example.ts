/**
 * Integration example: Using TypeScript analyzer with Python RAG output
 *
 * This script demonstrates how to:
 * 1. Load lifecycle analysis generated by the Python RAG system
 * 2. Perform graph analysis
 * 3. Export visualizations
 */

import { writeFile } from 'fs/promises';
import { LifecycleParser } from './index.js';

async function analyzeLifecycleFromPython() {
  console.log('üîç ArkUI Lifecycle Integration Example\n');

  // Path to Python-generated output
  const inputPath = 'data/outputs/json/test_lifecycle.json';

  try {
    // 1. Load the RAG-generated JSON
    console.log(`üìñ Loading: ${inputPath}`);
    const graph = await LifecycleParser.fromFile(inputPath);
    console.log('‚úì Successfully loaded lifecycle graph\n');

    // 2. Display basic information
    const stats = graph.getStats();
    console.log('üìä Graph Statistics:');
    console.log(`   Nodes: ${stats.nodeCount}`);
    console.log(`   Edges: ${stats.edgeCount}`);
    console.log(`   Has cycles: ${stats.hasCycles}`);
    console.log(`   Root nodes: ${stats.rootNodes.join(', ')}`);
    console.log(`   Leaf nodes: ${stats.leafNodes.join(', ')}\n`);

    // 3. Show dynamic behavior
    console.log('üí° Dynamic Behavior:');
    console.log(`   ${graph.getDynamicBehavior()}\n`);

    // 4. List all lifecycle functions
    console.log('üìã Lifecycle Functions:');
    const nodes = graph.getAllNodes();
    for (const node of nodes) {
      const successors = graph.getSuccessors(node.func.name);
      const arrow = successors.length > 0 ? ` ‚Üí ${successors.join(', ')}` : '';
      console.log(`   ${node.func.name} [${node.func.scope}]${arrow}`);
      console.log(`      ${node.func.description}`);
    }
    console.log();

    // 5. Perform topological sort
    try {
      const sorted = graph.topologicalSort();
      console.log('üîÑ Topological Order (Execution Sequence):');
      sorted.forEach((name, index) => {
        console.log(`   ${index + 1}. ${name}`);
      });
      console.log();
    } catch (error) {
      console.log('‚ö† Cannot perform topological sort (graph contains cycles)\n');
    }

    // 6. Find specific paths
    const rootNodes = stats.rootNodes;
    const leafNodes = stats.leafNodes;
    if (rootNodes.length > 0 && leafNodes.length > 0) {
      console.log('üîé Path Analysis:');
      const path = graph.findPath(rootNodes[0]!, leafNodes[0]!);
      if (path) {
        console.log(`   ${rootNodes[0]} ‚Üí ${leafNodes[0]}:`);
        console.log(`   ${path.join(' ‚Üí ')}\n`);
      }
    }

    // 7. Export to DOT format for visualization
    const dotContent = graph.toDot();
    const dotPath = 'data/outputs/visualizations/lifecycle_graph.dot';
    await writeFile(dotPath, dotContent, 'utf-8');
    console.log(`üìÅ Exported to DOT format: ${dotPath}`);
    console.log('   Generate image with: dot -Tpng data/outputs/visualizations/lifecycle_graph.dot -o lifecycle_graph.png\n');

    // 8. Export back to JSON (for verification)
    const jsonOutput = graph.toJSON();
    const jsonPath = 'data/outputs/archives/lifecycle_graph_export.json';
    await writeFile(jsonPath, JSON.stringify(jsonOutput, null, 2), 'utf-8');
    console.log(`üìÅ Exported to JSON: ${jsonPath}\n`);

    console.log('‚úÖ Analysis complete!');

  } catch (error) {
    console.error('‚ùå Error:', error);
    process.exit(1);
  }
}

// Run the integration example
analyzeLifecycleFromPython().catch(console.error);
